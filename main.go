package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	//	"os/exec"
	"os/signal"

	//	"strconv"
	//	"strings"
	"syscall"
	"time"

	"github.com/JoshuaDoes/json"
	"github.com/otiai10/copy"
	flag "github.com/spf13/pflag"

	"github.com/LinusGates/osmgr"
	"github.com/LinusGates/reghive"
)

var (
	configFile         string //path to menu configuration
	keyCalibrationFile string //path to keyboard calibration, can be written for embedded devices or generated by first run calibrator
	hLines             int    //horizontal lines for screen
	vLines             int    //vertical lines for screen

	keyCalibration map[string][]*MenuKeycodeBinding = make(map[string][]*MenuKeycodeBinding)
	menuConfig     *MenuConfig                      //menu configuration
	menuEngine     *MenuEngine                      //menu engine/runtime/???

	SOURCEIMG *WIM
	SOURCEIDX int
	SOURCES   []*WIM
)

type MenuConfig struct {
	Environment map[string]string                `json:"environment"`
	HomeMenu    string                           `json:"homeMenu"`
	Menus       map[string]*MenuItemList         `json:"menus"`
	Keyboards   map[string][]*MenuKeycodeBinding `json:"keyboards"`
}

func main() {
	calibrate()
	clear(5)

	wims, _ := WalkMatch("sources", "*.*")
	if len(wims) > 0 {
		for i := 0; i < len(wims); i++ {
			wiminfo, err := WIMInfo(wims[i])
			if err == nil { //We only want valid WIM and ESD files that don't fail to parse
				SOURCES = append(SOURCES, wiminfo)
			}
		}
	} else {
		menuEngine.ErrorText("No install sources are available!")
		return
	}

	menuEngine.Hook("install-select_wim", func(me *MenuEngine) {
		menu := me.Menus["install-select_wim"]
		menu.Items = make([]*MenuItem, 0)

		for i := 0; i < len(SOURCES); i++ {
			editions := ""
			for j := 0; j < len(SOURCES[i].IMAGE); j++ {
				if editions != "" {
					editions += "\n - "
				}
				editions += SOURCES[i].IMAGE[j].Summary
			}
			menu.AddItem(filepath.Base(SOURCES[i].Path), editions, "setvar WIM "+SOURCES[i].Path, "menu install-select_edition")
		}
	})
	menuEngine.Hook("install-select_edition", func(me *MenuEngine) {
		menu := me.Menus["install-select_edition"]
		menu.Items = make([]*MenuItem, 0)

		if wim, ok := me.Environment["WIM"]; ok && wim != "" {
			wiminfo, err := WIMInfo(wim)
			if err != nil {
				delete(me.Environment, "WIM")
				menu.Title = "Failed to verify WIM!\n\n" + err.Error()
				return
			}

			if len(wiminfo.IMAGE) == 0 {
				delete(me.Environment, "WIM")
				menu.Title = "WIM verified, but has no editions!"
				return
			}
			SOURCEIMG = wiminfo

			for i := 0; i < len(wiminfo.IMAGE); i++ {
				wimimage := wiminfo.IMAGE[i]
				menu.AddItem(wimimage.INDEX+". "+wimimage.NAME.Text, wimimage.Summary, "setvar INDEX "+wimimage.INDEX, "menu install-select_disk")
			}
		} else {
			me.ErrorText("No WIM was specified!")
		}
	})
	menuEngine.Hook("install-select_disk", func(me *MenuEngine) {
		menu := me.Menus["install-select_disk"]
		menu.Items = make([]*MenuItem, 0)

		//We select an edition before reaching here, so set our environment now
		wimindex, err := strconv.Atoi(me.Environment["INDEX"])
		if err != nil {
			menu.Title = "Failed to convert index " + me.Environment["INDEX"] + " into a number!"
			return
		}
		SOURCEIDX = wimindex - 1
		me.Environment["NAME"] = SOURCEIMG.IMAGE[SOURCEIDX].NAME.Text
		me.Environment["DESC"] = SOURCEIMG.IMAGE[SOURCEIDX].DESCRIPTION.Text
		me.Environment["ROOT"] = SOURCEIMG.IMAGE[SOURCEIDX].WINDOWS.SYSTEMROOT.Text
		me.Environment["MAJOR"] = SOURCEIMG.IMAGE[SOURCEIDX].WINDOWS.VERSION.MAJOR.Text
		me.Environment["MINOR"] = SOURCEIMG.IMAGE[SOURCEIDX].WINDOWS.VERSION.MINOR.Text
		me.Environment["BUILD"] = SOURCEIMG.IMAGE[SOURCEIDX].WINDOWS.VERSION.BUILD.Text
		me.Environment["SPLVL"] = SOURCEIMG.IMAGE[SOURCEIDX].WINDOWS.VERSION.SPLEVEL.Text
		me.Environment["SPVER"] = SOURCEIMG.IMAGE[SOURCEIDX].WINDOWS.VERSION.SPBUILD.Text
		me.Environment["SUM"] = SOURCEIMG.IMAGE[SOURCEIDX].Summary

		switch me.Environment["MAJOR"] {
		case "6":
			switch me.Environment["MINOR"] {
			case "0":
				me.Environment["WINDOWS"] = "Vista"
				if me.Environment["BOOT"] == "MBR7" {
					me.Environment["BOOT"] = "MBRVISTA"
				}
			case "1":
				me.Environment["WINDOWS"] = "7"
			case "2":
				me.Environment["WINDOWS"] = "8"
			case "3":
				me.Environment["WINDOWS"] = "8.1"
			}
		case "10":
			switch me.Environment["MINOR"] {
			case "0":
				build, _ := strconv.Atoi(me.Environment["BUILD"])
				if build < 20000 {
					me.Environment["WINDOWS"] = "10"
				} else {
					me.Environment["WINDOWS"] = "11"
				}
			}
		}
		if windows, ok := me.Environment["WINDOWS"]; !ok || windows == "" {
			menu.Title = "Unsupported NT version " + me.Environment["MAJOR"] + "." + me.Environment["MINOR"]
			return
		}

		guid, err := reghive.GenerateGuid()
		if err != nil {
			me.ErrorText("Failed to generate GUID for this install!\n\n" + err.Error())
			return
		}
		me.Environment["GUID"] = guid

		if _, err := os.Stat("/sys/firmware/efi"); err != nil {
			me.Environment["BOOT"] = "MBR7"
		} else {
			me.Environment["BOOT"] = "EFI"
		}

		added := 0
		disks := osmgr.GetDisks()
		for i := 0; i < len(disks); i++ {
			disk := disks[i]
			added++
			menu.AddItem(fmt.Sprintf("%s (%s, /dev/%s)", disk.Model, disk.Size, disk.Block), "This will FORMAT your "+disk.Model+" and any data on it will be permanently destroyed!", "setvar DISK "+disk.Block, "menu install-windows-confirmation")
		}
		if added == 0 {
			menu.Title = "No disks were found!"
			return
		}
	})
	menuEngine.Hook("install-windows-confirmation", func(me *MenuEngine) {
		disks := osmgr.GetDisks()
		for i := 0; i < len(disks); i++ {
			disk := disks[i]
			if disk.Block != me.Environment["DISK"] {
				continue
			}
			me.Environment["DISKPRETTY"] = fmt.Sprintf("%s (%s, /dev/%s)", disk.Model, disk.Size, disk.Block)
			break
		}
	})
	menuEngine.Hook("install-windows", func(me *MenuEngine) {
		me.Redraw()
		me.Lock()
		defer me.Unlock()

		//Perform the Windows installation!
		wim := me.Environment["WIM"]
		index := me.Environment["INDEX"]
		disk := me.Environment["DISK"]
		target := "/dev/" + disk
		img := me.Environment["windowsimg"]
		boot := me.Environment["windowsboot"]

		menu := me.Menus["install-windows"]
		menu.Items = make([]*MenuItem, 0)
		me.Redraw()

		menu.AddItem("* Unmounting "+target, "", "note", "")
		me.Redraw()
		partitions, err := ioutil.ReadFile("/proc/partitions")
		if err != nil {
			me.ErrorText("Failed to read partition tables!\n\n" + err.Error())
			return
		}
		matcher, _ := regexp.Compile("(?:\\d) ([a-z]+)(\\d)")
		matches := matcher.FindAllStringSubmatch(string(partitions), -1)
		if len(matches) == 0 {
			me.ErrorText("No disks were found!")
			return
		}
		for i := 0; i < len(matches); i++ {
			disk := "/dev/" + matches[i][1]
			if disk != target {
				//menu.AddItem("* Skipping disk "+disk+" because it is not "+target, "", "note", "")
				//me.Redraw()
				continue
			}
			part := matches[i][2]
			drive := disk + part
			//menu.AddItem(fmt.Sprintf("\n%v\n%v\n", []byte(target), []byte(drive)), "", "note", "")
			//menu.AddItem("* Unmounting drive "+drive, "", "note", "")
			//me.Redraw()
			_, _ = Run("umount", drive)
		}

		menu.AddItem("* Making sure "+target+" is unmounted properly", "", "note", "")
		me.Redraw()
		mounts, err := ioutil.ReadFile("/proc/mounts")
		if err != nil {
			me.ErrorText("Failed to read mounts!\n\n" + err.Error())
			return
		}
		matcher, _ = regexp.Compile("(/dev/[a-z]+)(\\d)")
		matches = matcher.FindAllStringSubmatch(string(mounts), -1)
		if len(matches) > 0 {
			for i := 0; i < len(matches); i++ {
				disk := matches[i][1]
				if disk != target {
					//menu.AddItem("* Skipping disk "+disk+" because it is not "+target, "", "note", "")
					//me.Redraw()
					continue
				}
				part := matches[i][2]
				drive := disk + part
				me.ErrorText("Failed to unmount " + drive + "!")
				return
			}
		}

		menu.AddItem("* Determining how to partition Windows", "", "note", "")
		me.Redraw()
		targetBOOT := target
		targetIMG := target
		targetREC := target
		if len(disk) > 6 && string(disk[:6]) == "mmcblk" {
			targetBOOT += "p"
			targetIMG += "p"
			targetREC += "p"
		}
		switch me.Environment["BOOT"] {
		case "MBRVISTA", "MBR7":
			targetBOOT += "1"
			targetIMG += "2"
		case "EFI":
			targetBOOT += "1"
			targetIMG += "3"
			targetREC += "2"
		}

		///*
		menu.AddItem("* Creating Windows partitions on "+target, "", "note", "")
		me.Redraw()
		switch me.Environment["BOOT"] {
		case "MBRVISTA", "MBR7":
			output, err := Run("sh", "fdisk_mbr.sh", target)
			if err != nil {
				me.ErrorText("Failed to call fdisk!\n\n" + err.Error() + "\n\n" + string(output))
				return
			}
		case "EFI":
			output, err := Run("sh", "fdisk_gpt.sh", target)
			if err != nil {
				me.ErrorText("Failed to call fdisk!\n\n" + err.Error() + "\n\n" + string(output))
				return
			}
		}

		switch me.Environment["BOOT"] {
		case "MBRVISTA", "MBR7":
			menu.AddItem("* Formatting "+targetBOOT+" to NTFS", "", "note", "")
			me.Redraw()
			output, err := Run("mkfs.ntfs", "--quick", "--label", "System Reserved", targetBOOT)
			if err != nil {
				me.ErrorText("Failed to format boot partition!\n\n" + err.Error() + "\n\n" + string(output))
				return
			}
		case "EFI":
			menu.AddItem("* Formatting "+targetBOOT+" to FAT32", "", "note", "")
			me.Redraw()
			output, err := Run("mkfs.fat", "-F", "32", targetBOOT)
			if err != nil {
				me.ErrorText("Failed to format boot partition!\n\n" + err.Error() + "\n\n" + string(output))
				return
			}
		}

		if targetREC != target {
			menu.AddItem("* Formatting "+targetREC+" to NTFS", "", "note", "")
			me.Redraw()
			output, err := Run("mkfs.ntfs", "--quick", "--label", "Recovery", targetREC)
			if err != nil {
				me.ErrorText("Failed to format recovery partition!\n\n" + err.Error() + "\n\n" + string(output))
				return
			}
		}

		menu.AddItem("* Formatting "+targetIMG+" to NTFS", "", "note", "")
		me.Redraw()
		output, err := Run("mkfs.ntfs", "--quick", "--label", "Windows", targetIMG)
		if err != nil {
			me.ErrorText("Failed to format Windows partition!\n\n" + err.Error() + "\n\n" + string(output))
			return
		}

		switch me.Environment["BOOT"] {
		case "MBRVISTA":
			menu.AddItem("* Installing Windows Vista Master Boot Record (MBR) to "+target, "", "note", "")
			me.Redraw()
			output, err := Run("ms-sys", "--mbrvista", target)
			if err != nil {
				me.ErrorText("Failed to install the Windows Vista MBR!\n\n" + err.Error() + "\n\n" + string(output))
				return
			}
		case "MBR7":
			menu.AddItem("* Installing Windows 7 Master Boot Record (MBR) to "+target, "", "note", "")
			me.Redraw()
			output, err := Run("ms-sys", "--mbr7", target)
			if err != nil {
				me.ErrorText("Failed to install the Windows 7 MBR!\n\n" + err.Error() + "\n\n" + string(output))
				return
			}
		}

		switch me.Environment["BOOT"] {
		case "MBRVISTA", "MBR7":
			menu.AddItem("* Installing Windows 7 NTFS boot record to "+targetBOOT, "", "note", "")
			me.Redraw()
			output, err := Run("ms-sys", "--ntfs", targetBOOT)
			if err != nil {
				me.ErrorText("Failed to install the Windows 7 NTFS boot record!\n\n" + err.Error() + "\n\n" + string(output))
				return
			}
		}

		menu.AddItem("* Applying "+wim+":"+index+" to "+targetIMG, "", "note", "")
		me.Redraw()
		err = RunRealtime("wimapply", wim, index, targetIMG)
		if err != nil {
			me.ErrorText("Failed to apply the Windows image!\n\n" + err.Error())
			return
		}
		//*/

		menu.AddItem("* Mounting Windows partitions from "+target, "", "note", "")
		me.Redraw()
		output, err = Run("mount", "-o", "rw", targetBOOT, boot)
		//output, err := Run("mount", "-o", "rw", targetBOOT, boot)
		if err != nil {
			me.ErrorText("Failed to mount the boot partition!\n\n" + err.Error() + "\n\n" + string(output))
			return
		}
		output, err = Run("mount", "-o", "ro", targetIMG, img)
		if err != nil {
			me.ErrorText("Failed to mount the Windows partition!\n\n" + err.Error() + "\n\n" + string(output))
			return
		}

		menu.AddItem("* Installing the Windows bootloader to "+targetBOOT, "", "note", "")
		me.Redraw()

		menu.AddItem("* - PCAT", "", "note", "")
		me.Redraw()
		err = copy.Copy(img+"/Windows/Boot/PCAT", boot+"/Boot")
		if err != nil {
			me.ErrorText("Failed to install PCAT!\n\n" + err.Error())
			return
		}
		err = os.Rename(boot+"/Boot/bootmgr", boot+"/bootmgr")
		if err != nil {
			me.ErrorText("Failed to install bootmgr!\n\n" + err.Error())
			return
		}
		err = copy.Copy(img+"/Windows/Boot/Fonts", boot+"/Boot/Fonts")
		if err != nil {
			me.ErrorText("Failed to install Fonts!\n\n" + err.Error())
			return
		}

		switch me.Environment["BOOT"] {
		case "EFI":
			switch me.Environment["WINDOWS"] {
			case "8", "8.1", "10", "11":
				err = copy.Copy(img+"/Windows/Boot/Resources", boot+"/Boot/Resources")
				if err != nil {
					me.ErrorText("Failed to install Resources!\n\n" + err.Error())
					return
				}
				err = os.Rename(boot+"/Boot/bootnxt", boot+"/BOOTNXT")
				if err != nil {
					me.ErrorText("Failed to install bootnxt!\n\n" + err.Error())
					return
				}
			}

			menu.AddItem("* - EFI", "", "note", "")
			me.Redraw()
			err = os.MkdirAll(boot+"/EFI/Boot", 0777)
			if err != nil {
				me.ErrorText("Failed to create EFI boot folders!\n\n" + err.Error())
				return
			}
			err = os.MkdirAll(boot+"/EFI/Microsoft", 0777)
			if err != nil {
				me.ErrorText("Failed to create EFI boot folders!\n\n" + err.Error())
				return
			}
			err = copy.Copy(img+"/Windows/Boot/EFI", boot+"/EFI/Microsoft/Boot")
			if err != nil {
				me.ErrorText("Failed to install EFI!\n\n" + err.Error())
				return
			}
			err = copy.Copy(boot+"/EFI/Microsoft/Boot/bootmgfw.efi", boot+"/EFI/Boot/bootx64.efi")
			if err != nil {
				me.ErrorText("Failed to copy EFI boot manager!\n\n" + err.Error())
				return
			}
			err = copy.Copy(boot+"/Boot/Fonts", boot+"/EFI/Microsoft/Boot/Fonts")
			if err != nil {
				me.ErrorText("Failed to copy EFI Fonts!\n\n" + err.Error())
				return
			}

			switch me.Environment["WINDOWS"] {
			case "8", "8.1", "10", "11":
				err = copy.Copy(boot+"/Boot/Resources", boot+"/EFI/Microsoft/Boot/Resources")
				if err != nil {
					me.ErrorText("Failed to copy EFI Resources!\n\n" + err.Error())
					return
				}
			}
		}

		menu.AddItem("* Adjusting BCD-Template hive for the new install", "", "note", "")
		me.Redraw()
		err = copy.Copy(img+"/Windows/System32/config/BCD-Template", boot+"/BCD")
		if err != nil {
			me.ErrorText("Failed to copy BCD-Template into staging area!\n\n" + err.Error())
			return
		}

		bcd, err := reghive.OpenRegistryHive(boot + "/BCD")
		if err != nil {
			me.ErrorText("Failed to open BCD!\n\n" + err.Error())
			return
		}

		rootNode, err := bcd.GetNode("/")
		if err != nil {
			me.ErrorText("Failed to get root node from BCD!\n\n" + err.Error())
			return
		}

		menu.AddItem("* Finished adjusting BCD!", "View the new BCD tree", "note", rootNode.String())

		menu.AddItem("* - Injecting BCD into PCAT", "", "note", "")
		me.Redraw()
		err = copy.Copy(boot+"/BCD", boot+"/Boot/BCD")
		if err != nil {
			me.ErrorText("Failed to install BCD into PCAT!\n\n" + err.Error())
			return
		}

		switch me.Environment["BOOT"] {
		case "EFI":
			menu.AddItem("* - Injecting BCD into EFI", "", "note", "")
			me.Redraw()
			err = copy.Copy(img+"/Windows/System32/config/BCD-Template", boot+"/EFI/Microsoft/Boot/BCD")
			if err != nil {
				me.ErrorText("Failed to install BCD into EFI!\n\n" + err.Error())
				return
			}
		}

		menu.AddItem("* Unmounting Windows partitions", "", "note", "")
		me.Redraw()
		output, err = Run("umount", boot)
		if err != nil {
			me.ErrorText("Failed to unmount boot!\n\n" + err.Error() + "\n\n" + string(output))
			return
		}
		output, err = Run("umount", img)
		if err != nil {
			me.ErrorText("Failed to unmount Windows!\n\n" + err.Error() + "\n\n" + string(output))
			return
		}

		me.Unlock()
		menu.AddItem("", "", "divider", "2")
		menu.AddItem("Done!", "", "note", "")
		me.Redraw()

		time.Sleep(1 * time.Second)
		menu.AddItem("", "", "divider", "2")
		menu.AddItem("Reboot to complete the install", "Make sure to remove this installation medium before pressing enter!", "internal", "reboot")
		menu.AddItem("Shut down to complete the install later", "Make sure to remove this installation medium before pressing enter!", "internal", "shutdown")
		menu.AddItem("", "", "divider", "2")
		menu.AddItem("Return to setup to do something else", "Takes you back to the install and recovery choices", "menu", "setup")
		menu.NoSelector = false
		me.ItemCursor = len(menu.Items) - 4
		me.Redraw()
	})

	menuEngine.Home()
	bindKeys()

	sc := make(chan os.Signal, 1)
	signal.Notify(sc, syscall.SIGINT)
	<-sc
}

func clear(delay time.Duration) {
	for lines := 0; lines < menuEngine.LinesV; lines++ {
		fmt.Printf("\n")
		if delay > 0 {
			time.Sleep(delay * time.Millisecond)
		}
	}
}

func render(menu string) {
	//clear(0)
	lines := strings.Split(menu, "\n")
	for i := 0; i < hLines; i++ {
		fmt.Printf(" ")
	}
	fmt.Printf("\n" + menu)
	for i := 0; i < (vLines - len(lines) - 1); i++ {
		fmt.Printf("\n")
	}
}

func init() {
	//Apply all command-line flags
	flag.StringVar(&configFile, "menu", "menu.json", "path to menu configuration")
	flag.StringVar(&keyCalibrationFile, "keyCalibration", "keyCalibration.json", "path to keyboard calibration, generated by calibrator if not present")
	flag.IntVar(&hLines, "hLines", 0, "horizontal lines available to virtual screen")
	flag.IntVar(&vLines, "vLines", 0, "vertical lines available to virtual screen")
	flag.Parse()

	if hLines <= 0 {
		hLines = 80
	}
	if vLines <= 0 {
		vLines = 24
	}

	keyCalibrationJSON, err := ioutil.ReadFile(keyCalibrationFile)
	if err == nil {
		keyCalibration = make(map[string][]*MenuKeycodeBinding)
		err = json.Unmarshal(keyCalibrationJSON, &keyCalibration)
		if err != nil {
			panic(fmt.Sprintf("error parsing key calibration file: %v", err))
		}
	}

	configJSON, err := ioutil.ReadFile(configFile)
	if err != nil {
		panic(fmt.Sprintf("error reading config file: %v", err))
	}

	menuConfig = &MenuConfig{}
	err = json.Unmarshal(configJSON, menuConfig)
	if err != nil {
		panic(fmt.Sprintf("error parsing config file: %v", err))
	}

	menuEngine = NewMenuEngine(render, hLines, vLines)
	menuEngine.Environment = menuConfig.Environment
	workingDir, _ := os.Getwd()
	menuEngine.Environment["WORKINGDIR"] = workingDir
	menuEngine.Environment["WD"] = workingDir

	for id, itemList := range menuConfig.Menus {
		menuEngine.AddMenu(id, itemList)
	}

	menuEngine.HomeMenu = menuConfig.HomeMenu

	SOURCES = make([]*WIM, 0)
}

func WalkMatch(root, pattern string) ([]string, error) {
	var matches []string
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if matched, err := filepath.Match(pattern, filepath.Base(path)); err != nil {
			return err
		} else if matched {
			matches = append(matches, path)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return matches, nil
}
