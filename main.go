package main

import (
	"fmt"
	"io/ioutil"
	"math"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"
	"time"

	flag "github.com/spf13/pflag"
	"github.com/JoshuaDoes/json"
	"seehuhn.de/go/ncurses"
)

var (
	workingDir         string //where the menu should treat as its working directory
	configFile         string //path to menu configuration
	keyCalibrationFile string //path to keyboard calibration, can be written for embedded devices or generated by first run calibrator

	keyCalibration map[string][]*MenuKeycodeBinding = make(map[string][]*MenuKeycodeBinding)
	menuConfig     *MenuConfig                      //menu configuration
	menuEngine     *MenuEngine                      //menu engine/runtime/???

	terminal *ncurses.Window //interfaces with the actual terminal window

	SOURCEIMG *WIM
	SOURCEIDX int
	SOURCES   []*WIM
)

func init() {
	//Apply all command-line flags
	flag.StringVar(&workingDir, "workingDir", "", "path to treat as working directory")
	flag.StringVar(&configFile, "menu", "", "path to menu configuration")
	flag.StringVar(&keyCalibrationFile, "keyCalibration", "", "path to keyboard calibration, generated by calibrator if not present")
	flag.Parse()

	if workingDir == "" {
		workingDir, _ = os.Getwd()
	}
	if configFile == "" {
		configFile = workingDir + "/menu.json"
	}
	if keyCalibrationFile == "" {
		keyCalibrationFile = workingDir + "/keyCalibration.json"
	}

	configJSON, err := ioutil.ReadFile(configFile)
	if err != nil {
		panic(fmt.Sprintf("error reading config file: %v", err))
	}

	menuConfig = &MenuConfig{}
	err = json.Unmarshal(configJSON, menuConfig)
	if err != nil {
		panic(fmt.Sprintf("error parsing config file: %v", err))
	}

	menuEngine = NewMenuEngine(render)
	menuEngine.Environment = menuConfig.Environment
	menuEngine.Environment["WORKINGDIR"] = workingDir
	menuEngine.Environment["WD"] = workingDir

	for id, itemList := range menuConfig.Menus {
		menuEngine.AddMenu(id, itemList)
	}

	menuEngine.HomeMenu = menuConfig.HomeMenu

	SOURCES = make([]*WIM, 0)
}

type MenuConfig struct {
	Environment map[string]string                `json:"environment"`
	HomeMenu    string                           `json:"homeMenu"`
	Menus       map[string]*MenuItemList         `json:"menus"`
	Keyboards   map[string][]*MenuKeycodeBinding `json:"keyboards"`
}

func main() {
	terminal = ncurses.Init()
	defer ncurses.EndWin()

	//Check for terminal resizing almost once per frame, assuming 60Hz
	go Interval(time.Millisecond * 17, func() error {
		height, width := terminal.GetMaxYX()
		oldV := menuEngine.LinesV
		oldH := menuEngine.LinesH
		menuEngine.LinesV = height
		menuEngine.LinesH = width
		if oldV != height || oldH != width {
			if menuEngine.LoadedMenu != "" {
				menuEngine.Redraw()
			}
		}
		return nil
	})

	if err := calibrate(); err != nil {
		printf("Error calibrating: %v\n", err)
		return //Allows ncurses to gracefully exit
	}
	clear()

	wims, _ := WalkMatch("sources", "*.*")
	if len(wims) > 0 {
		for i := 0; i < len(wims); i++ {
			wiminfo, err := WIMInfo(wims[i])
			if err == nil { //We only want valid WIM and ESD files that don't fail to parse
				SOURCES = append(SOURCES, wiminfo)
			}
		}
	} else {
		menuEngine.ErrorText("No install sources are available!", "")
		return
	}

	menuEngine.Hook("install-select_wim", hookInstallSelectWim)
	menuEngine.Hook("install-select_edition", hookInstallSelectEdition)
	menuEngine.Hook("install-select_disk", hookInstallSelectDisk)
	menuEngine.Hook("install-windows-confirmation", hookInstallWindowsConfirmation)
	menuEngine.Hook("install-windows", hookInstallWindows)

	menuEngine.Home()
	bindKeys()

	sc := make(chan os.Signal, 1)
	signal.Notify(sc, syscall.SIGINT)
	<-sc
}

func clear() {
	terminal.Erase()
}

func render(mr *MenuRender) {
	headLines := padStr(strings.Split(mr.Header, "\n"), menuEngine.LinesH)
	head := strings.Join(headLines, "\n")
	menuLines := padStr(strings.Split(mr.Menu, "\n"), menuEngine.LinesH)
	menu := strings.Join(menuLines, "\n")
	footLines := padStr(strings.Split(mr.Footer, "\n"), menuEngine.LinesH)
	foot := strings.Join(footLines, "\n")

	text := fmt.Sprintf("\n%s\n\n%s", head, menu)
	newLines := 3
	height := len(headLines) + len(menuLines) + len(footLines) + newLines

	if height >= menuEngine.LinesV {
		text = fmt.Sprintf("%s\n%s", menu, foot)
	} else {
		pad := int(math.Floor(float64(menuEngine.LinesV - height))) + 1
		for i := 0; i < pad; i++ {
			text += "\n"
		}
		text += foot
	}

	clear()
	terminal.Println(text)
	terminal.Refresh()
}

func printf(format string, args ...interface{}) {
	terminal.Printf(format, args...)
	terminal.Refresh()
}

func println(line string) {
	terminal.Println(line)
	terminal.Refresh()
}

//padStr pads the left side of each line with spaces to center the text within the horizontal space while remaining left-justified
func padStr(lines []string, width int) []string {
	longest := 0
	for i := 0; i < len(lines); i++ {
		if len(lines[i]) > longest {
			longest = len(lines[i])
		}
	}
	if longest >= width {
		return lines
	}

	pad := int(math.Floor(float64(width - longest) / 2))
	padding := ""
	for i := 0; i < pad; i++ {
		padding += " "
	}

	for i := 0; i < len(lines); i++ {
		lines[i] = padding + lines[i]
	}
	return lines
}

func WalkMatch(root, pattern string) ([]string, error) {
	var matches []string
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if matched, err := filepath.Match(pattern, filepath.Base(path)); err != nil {
			return err
		} else if matched {
			matches = append(matches, path)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return matches, nil
}
